使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型

自己的话说：使用枚举的值可以获得枚举属性的名称，使用枚举的属性获取枚举的值

`数字枚举`可以被混入到`计算过的和常量成员`。**不带初始化器的枚举**要么被放在第一的位置，要么被放在使用了数字常量或其它常量初始化了的枚举后面。下面的情况是不被允许的：

    enum E {
        A = getSomeValue(),
        B, // error! 'A' is not constant-initialized, so 'B' needs an initializer
    }

在一个`字符串枚举`里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。

由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息，字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。

从技术的角度来说，枚举可以混合字符串和数字成员，但是不要这么做

每个枚举成员都带有一个值，它可以是常量或计算出来的。

    当满足如下条件时，枚举成员被当作是常量：
        1. 它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值 0.
        2. 它不带有初始化器且它之前的枚举成员是一个数字常量。
        

所有其它情况的枚举成员被当作是需要计算得出的值。

存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为：

    任何字符串字面量
    任何数字字面量
    应用了一元 - 符号的数字字面量

当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义。首先，枚举成员成为了类型。其次，枚举类型本身变成了每个枚举成员的联合(作为联合类型)。

    enum ShapeKind {
        Circle,
        Square,
    }

    interface Circle {
        kind: ShapeKind.Circle;
        radius: number;
    }

    interface Square {
        kind: ShapeKind.Square;
        sideLength: number;
    }

    let c: Circle = {
        kind: ShapeKind.Square,
        // Error!
        radius: 100,
    }

**联合类型**

    enum E {
        Foo,
        Bar,
    }

    // E作为Foo和Bar的联合类型使用

    function f(x: E) {
        if (x !== E.Foo || x !== E.Bar) {
            // 短路检查没有通过，那么x则只能为 E.Foo
        }
    }

枚举是在运行时真正存在的对象。

    enum E {
        X, Y, Z
    }

    function f(obj: { X: number }) {
        return obj.X;
    }

    f(E);


数字枚举成员具有`反向映射`，从枚举值到枚举名字。

    enum Enum {
        A
    }
    let a = Enum.A;
    let nameOfA = Enum[a]; // "A"

编译成

    var Enum;
    (function (Enum) {
        Enum[Enum["A"] = 0] = "A";
    })(Enum || (Enum = {}));
    var a = Enum.A;
    var nameOfA = Enum[a]; // "A"

枚举类型被编译成一个对象，它包含了正向映射（ name -> value）和反向映射（ value -> name）。引用枚举成员总会生成为对属性访问并且永远也不会内联代码。

> `不会为字符串枚举成员生成反向映射。`

为了避免在额外生成的代码上的开销和间接的对枚举成员的访问，我们可以使用`const枚举`。常量枚举通过在枚举上使用const修饰符来定义。

常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。

    const enum Enum {
        A = 1,
        B = A * 2
    }

`外部枚举`用来描述已经存在的枚举类型的形状。

    declare enum Enum {
        A = 1,
        B,
        C = 2
    }

外部枚举和非外部枚举之间有一个**重要的区别**，在正常的枚举里，没有初始化方法的成员被当成常数成员。对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的。
