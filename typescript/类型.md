> ## 类型推论

TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查

当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。

当候选类型不能使用的时候我们需要明确的指出类型。

如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型。

> ## 兼容性

TypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义类型形成对比。（在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于`类型的组成结构`，且不要求明确地声明。） 

TypeScript结构化类型系统的基本规则是，如果x要兼容y，那么y至少具有与x相同的属性, y有额外的属性不会发生错误。只有目标类型的成员会被一一检查是否兼容。这个比较过程是递归进行的，`检查每个成员及子成员`。

函数的比较，目标函数允许忽略参数，源函数要求必须的参数。

类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。

当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。

比较函数兼容性的时候，可选参数与必须参数是可互换的。 源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。

对于有`重载的函数`，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。

`枚举类型`与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的.

`类`与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。

`类的私有成员和受保护成员`会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。

对于没指定泛型类型的`泛型参数`时，会把所有泛型参数当成any比较。

> ## 类型断言

类型断言可以用来手动指定一个值的类型。

    <类型>值
或

    值 as 类型

类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的。

当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法。

这就是一种告诉ts类型的方法并不是类型转换。
